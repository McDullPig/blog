#### 1. 股票的最大利润

假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。

```js
// 当前最大利润为昨天最大利润（已出售）与今天价格减掉之前最低价格之间的最大值，由于dp只需要前一天状态，故用变量代替dp数组。
var maxProfit = function (prices) {
  let len = prices.length;
  if (!prices || len === 0) return [];
  let dp = 0,
    preMin = prices[0]; //当前最低价格当成第一个数， dp是最大利润
  for (let i = 1; i < len; i++) {
    if (prices[i] > preMin) {
      //只要价格大于前面的价格就计算利润
      dp = Math.max(dp, prices[i] - preMin);
    } else {
      //否则就把当前的价格当初最低价格
      preMin = prices[i];
    }
  }
  return dp;
};
```

#### 2. n 个骰子的点数

把 n 个骰子扔在地上，所有骰子朝上一面的点数之和为 s。输入 n，打印出 s 的所有可能的值出现的概率。

```js
var dicesProbability = function (n) {
  // 第一次的骰子概率都为 1/6
  let dp = new Array(6).fill(1 / 6);
  let init = 1 / 6;
  // 遍历有多少个骰子
  for (let i = 2; i <= n; i++) {
    // 长度是总的长度-（n-1）的长度
    let len = 6 * i - (i - 1);
    // temp[0] 是每个骰子都是 1 的概率，i 个骰子对应和为 i
    let temp = new Array(len).fill(0);
    // 遍历上一次的骰子每一个和对应的概率
    for (let j = 0; j < dp.length; j++) {
      // 这一次分别摇到 1 - 6，每一次的概率都是 1/6
      for (let k = 0; k < 6; k++) {
        // 当 j=0，k=0 时，dp[0] 是上一次 n - 1 个骰子都是摇到 1 的概率
        temp[0] = dp[0] * init;
        // 相当于上一次的骰子点数之和再加上这次摇到对应的点数的新和的概率
        // 当摇到3的时候，j=0 & k=2 + j=1 & k=1
        temp[j + k] += dp[j] * init;
      }
    }
    // i 个骰子的点数之和转移到 dp
    dp = temp;
  }
  return dp;
};
```

#### 3. 构建乘积数组

给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。

```js
// 动态规划： 两个数组，一个保存左边的乘积，一个保存右边的乘积，最后相乘
var constructArr = function (a) {
  let len = a.length;
  if (len <= 1) {
    return a;
  }
  let left = new Array(len).fill(1);
  for (let i = 1; i < len; i++) {
    left[i] = left[i - 1] * a[i - 1];
  }
  let right = new Array(len).fill(1);
  for (let i = len - 2; i >= 0; i--) {
    right[i] = right[i + 1] * a[i + 1];
  }
  let res = [];
  for (let i = 0; i < len; i++) {
    res[i] = left[i] * right[i];
  }
  return res;
};
```

#### 4. 减绳子

给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段，每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]_k[1]_...\*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 2\*3\*3 =18。 n<58

```js
// 动态规划：从小往大循环，每次使用之前的数
var cuttingRope = function (n) {
  let dp = new Array(n + 1).fill(1);
  for (let i = 3; i <= n; i++) {
    for (let j = 1; j < i; j++) {
      // 可以剪成 j 和 i-j,
      dp[i] = Math.max(dp[i], j * dp[i - j], j * (i - j)); //判断是保存的值大，还是这次剪的值大
    }
  }
  return dp[n];
};

//贪心法 ： 一个整数要拆成多个2和3的和，保证乘积最大，如果最后有一个1， 就让最后一个3+1
var cuttingRope = function (n) {
  if (n === 2) return 1;
  if (n === 3) return 2;
  // a的含义：n能拆成的3的个数
  const a = Math.floor(n / 3);
  const b = n % 3;

  // n是3的倍数
  if (b === 0) return Math.pow(3, a);
  // n是 3k + 1，例如7。拆成3、3、1。由于有1对结果无法有贡献，所以最后的3、1换成4
  if (b === 1) return Math.pow(3, a - 1) * 4;
  return Math.pow(3, a) * 2;
};
```

#### 5. 剪绳子 2:大数 n<1000

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

```js
// 循环：每次乘3都要取模，预防太大
var cuttingRope = function (n) {
  if (n < 4) return n - 1;
  let res = 1;
  while (n > 4) {
    res = (res * 3) % 1000000007;
    n -= 3;
  }
  return (res * n) % 1000000007;
};

// 动态规划
// BigInt 是一种内置对象，BigInt可以表示任意大的整数。
// Math.max不能求BigInt类型的最值
var cuttingRope = function (n) {
  let dp = new Array(n).fill(BigInt(1));
  for (let i = 0; i < n; i++) {
    for (let j = i - 1; j >= 0; j--) {
      dp[i] = max(dp[i], dp[j] * BigInt(i - j), BigInt((j + 1) * (i - j)));
    }
  }
  return dp[n - 1] % 1000000007;
};

const max = (...args) =>
  args.reduce((prev, curr) => (prev > curr ? prev : curr));
```

#### 6. 丑数

我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

> 输入: n = 10
> 输出: 12
> 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。

```js
// 丑数是只包含2、3、5的数，下一个丑数，是前一个丑数 *2 |*3|*5得到的，三个指针，它们指向的数只乘以2|3|5，在循环中，每次找分别*2，3，5中最小的数，然后相应的指针往前移。
var nthUglyNumber = function (n) {
  if (n <= 6) {
    return n;
  }
  let res = new Array(n);
  res[0] = 1;
  let pre2 = 0; //指向乘以2
  let pre3 = 0; //指向乘以3
  let pre5 = 0; //指向乘以5
  for (let i = 1; i < n; i++) {
    res[i] = Math.min(res[pre2] * 2, res[pre3] * 3, res[pre5] * 5);
    if (res[i] === res[pre2] * 2) {
      ++pre2;
    }
    if (res[i] === res[pre3] * 3) {
      ++pre3;
    }
    if (res[i] === res[pre5] * 5) {
      ++pre5;
    }
  }
  return res[n - 1];
};
```

#### 7. 礼物的最大价值

在一个 m\*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物

> 输入:
> [
> [1,3,1],
> [1,5,1],
> [4,2,1]
> ]
> 输出: 12
> 解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物

```js
var maxValue = function (grid) {
  let rows = grid.length;
  let cols = grid[0].length;
  if (rows === 0 || cols === 0) {
    return 0;
  }
  let dp = new Array(rows).fill(0).map(() => new Array(cols).fill(0)); //二维数组
  dp[0][0] = grid[0][0];
  for (let i = 1; i < cols; i++) {
    //第一列等于上面的加起来
    dp[0][i] = grid[0][i] + dp[0][i - 1];
  }
  for (let i = 1; i < rows; i++) {
    //第一行等于左边的加起来
    dp[i][0] = grid[i][0] + dp[i - 1][0];
  }
  for (let i = 1; i < rows; i++) {
    // 剩下的都是左边和上边哪个大 + 当前值
    for (let j = 1; j < cols; j++) {
      dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
    }
  }
  return dp[rows - 1][cols - 1];
};
```

#### 8、把数字翻译成字符串

给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

```js
var translateNum = function (num) {
  if (num < 0) {
    return 0;
  }
  if (num < 10) {
    return 1;
  }
  if (num <= 25 && num >= 10) {
    return 2;
  }
  let s = num.toString();
  let len = s.length;
  let dp = new Array(len + 1); //从小到大记录
  dp[1] = 1;
  dp[0] = 1;
  for (let i = 2; i <= len; i++) {
    let ch = Number(s[i - 2] + s[i - 1]);
    if (ch <= 25 && ch >= 10) {
      //在双位数中，可以拆分成双位数和两个单位数
      dp[i] = dp[i - 2] + dp[i - 1];
    } else {
      //25代表z，如果比25还大，就没有双位数的可能性，比10小，也没有双位数的可能性
      dp[i] = dp[i - 1];
    }
  }
  return dp[len];
};
```
